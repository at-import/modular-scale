@use "sass:math";
@use "sass:list";

@function step($v: 0, $base: false, $ratio: false, $thread: false, $settings: $settings) {

  // Parse settings
  $settings: settings($base,$ratio,$thread,$settings);
  $base: list.nth($settings, 1);
  $ratio: list.nth($settings, 2);

  // Render target values from settings.
  @if unit($ratio) != '' {
    $ratio: target($ratio,$base)
  }

  // Fast calc if not multi stranded
  @if(list.length($base) == 1) {
    @return math.pow($ratio, $v) * $base;
  }

  // Create new base array
  $bases: list.nth($base,1);

  // Normalize base values
  @for $i from 2 through list.length($base) {
    // initial base value
    $base: list.nth($base,$i);
    // If the base is bigger than the main base
    @if($base > list.nth($base,1)) {
      // divide the value until it aligns with main base.
      @while($base > list.nth($base,1)) {
        $base: math.div($base,$ratio);
      }
      $base: $base * $ratio;
    }
    // If the base is smaller than the main base.
    @else if ($base < list.nth($base,1)) {
      // pump up the value until it aligns with main base.
      @while $base < list.nth($base,1) {
        $base: $base * $ratio;
      }
    }
    // Push into new array
    $bases: append($bases,$base);
  }

  // Sort array from smallest to largest.
  $bases: sort($bases);

  // Find step to use in calculation
  $vtep: math.floor(math.div($v / list.length($bases)));
  // Find base to use in calculation
  $base: math.round((math.div($v / list.length($bases)) - $vtep) * list.length($bases)) + 1;

  @return math.pow($ratio, $vtep) * list.nth($bases,$base);
}